# DataFetcher

DataFetcher – це один із кінцевих сервісів у системі. Його основне завдання – приймати рішення про ліквідацію користувачів або додавання їх до WatchList для подальшого моніторингу. DataFetcher працює разом із Subgraph і може бути як кінцевим сервісом, так і передавати користувачів до TransmitFetcher для подальшої обробки, шляхом додавання юзерів в Redis Watchlist.

## Основні принципи роботи DataFetcher

![Data fetcher flow](../images/dataFetcherFlow.jpg)

### 1. Ініціалізація:

- DataFetcher приймає користувачів тільки від сервісу Subgraph. Він не має механізмів читання юзерів (на вході) з баз даних (Redis).
- Однак, DataFetcher має механізм роботи з Redis на виході. Після обробки користувачів, DataFetcher вирішує, чи додавати користувачів до WatchList у Redis, чи ні.

### 2. Аналіз користувачів:

- DataFetcher аналізує HF користувача, а також всі токени, що є в Borrow та Collateral у користувача. Він вибирає найбільший токен для ліквідації (Best Borrow та Best Collateral), оскільки ми можемо ліквідувати тільки один Borrow і один Collateral у користувача.
- Наприклад, на етапі Subgraph ми перевіряємо MinBorrow і MinCollateral у користувачів. Якщо значення MinBorrow становить 0,1 ETH, Subgraph пропускає користувача далі на DataFetcher. Однак, DataFetcher перевіряє всі токени у користувача і може побачити, що у користувача є три токени в Borrow. Він вибирає найбільший токен для ліквідації.
- Якщо найбільший з цих Borrow менше за MinBorrow (наприклад, менше 0,1 ETH), то такого користувача не буде ліквідовано.

### 3. Фільтри в параметрах:

- MinHfDel і MaxHfDel: Якщо DataFetcher бачить, що Health Factor користувача менший за MinHfDel або більший за MaxHfDel, він видаляє такого користувача з WatchList.
- MinHfLiq і MaxHfLiq: Якщо Health Factor користувача знаходиться в межах від MinHfLiq до MaxHfLiq, користувач буде відправлений на ліквідацію. Наприклад, якщо MaxHfLiq = 1 і MaxHfDel = 1.2, це означає, що якщо Health Factor користувача буде від 1 до 1.2, він залишатиметься в WatchList. Якщо більше 1.2, то користувач буде видалений з WatchList.
- MinBorrow і MinCollateral: На відміну від Subgraph, де MinBorrow і MinCollateral означають Total MinBorrow (загальне значення borrow по всіх токенах у borrow користувача), у DataFetcher ці параметри визначають значення для одного найбільшого borrow і одного найбільшого collateral.

### 4. Прийняття рішень:

- Якщо користувач підходить для ліквідації (наприклад, Health Factor < 1), DataFetcher відправляє подію liquidate (execute/liquidator/${protocol}) для LiqExecutor.
- Якщо користувач не підходить для ліквідації, DataFetcher додає його до WatchList у Redis для подальшого моніторингу. Наприклад, якщо Health Factor користувача > 1 або його мінімальний Borrow/Collateral не підходять для ліквідації, DataFetcher додає його до WatchList.
- DataFetcher також видаляє користувачів з WatchList, якщо їхні параметри змінилися і вони більше не відповідають критеріям для моніторингу або ліквідації.

### 5. Моніторинг та оновлення:

- Користувачі з WatchList будуть моніторитися TransmitFetcher.
- DataFetcher постійно перевіряє користувачів, що надходять від Subgraph, і приймає відповідні дії (наприклад, ліквідація або видалення з WatchList).

## Примітка

Як було описано в розділі Subgraph, якщо користувач відповідає критеріям ліквідації (наприклад, Health Factor 0,95), Subgraph буде постійно відправляти цього користувача на DataFetcher кожні півтори хвилини, поки користувач не буде ліквідований. Тому DataFetcher може часто отримувати одного і того ж користувача. Якщо DataFetcher вирішує не ліквідувати цього користувача, він все одно пройде на наступному кроці від Subgraph.

## Висновок

DataFetcher забезпечує детальний аналіз користувачів і приймає рішення про їх ліквідацію або додавання до WatchList для подальшого моніторингу. Його функціонал дозволяє перевіряти кожен окремий borrow та collattral юзера. І на основі їх параметрів відправляти озера на ліквідацію чи додавати в Wathlist для подальшого спостереження сервісом TransmitFetcher.

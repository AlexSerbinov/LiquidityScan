# Архітектура сервісу

## Вступ

Архітектура нашого проекту базується на системі Cinnamon, яка використовується більшістю проектів у нашій компанії. Ця архітектура передбачає використання певних шаблонів та стандартів, які допомагають забезпечити уніфікованість та ефективність усіх сервісів.

#### Конфігураційні файли

##### Глобальні конфігурації

Усі глобальні конфігурації зберігаються у файлі `configs/main.json`. Цей файл містить:

- URL та порт для Redis
- Посилання на Ethereum ноду
- Інші загальні змінні, необхідні для роботи сервісів

##### Конфігурації сервісів

Кожен проект має власні конфігурації, які зберігаються у папці `configs/workers`. Головний конфігураційний файл для кожного проекту називається `<назваСервісу>services.json`, наприклад: `blacklistServices.json`. Цей файл визначає:

- Об'єкт `Default Settings`, який містить спільні налаштування для всіх протоколів
- Налаштування для окремих протоколів (AAVE V1, AAVE V2, AAVE V3, Compound). Тут працює ієрархія параметрів. Якщо деякі налаштування вказані в `Default Settings`, вони використовуються в першу чергу. Але якщо якийсь параметр вказаний у конкретному протоколі, наприклад `V1`, то ці налаштування будуть вищими в ієрархії. Це зроблено для уникнення дублювання параметрів.

##### MQTT комунікація

Файл `sys.config.json` визначає URL для комунікації через MQTT теми. Усі сервіси нашої компанії, включаючи сервіси ліквідації, працюють через MQTT, надсилаючи повідомлення один одному з певними темами. Кожен сервіс має визначені теми для відправлення (`Notify`) та прослуховування (`Listen`).

##### REDIS - Основна база даних

У ранніх версіях як основна база даних використовувалася PostgreSQL. Тепер єдиною базою даних проекту є Redis.
Усі `redis namespaces` вказані у файлі `configs/redisNamespaces.js`

##### Приклад конфігурації тем

У конфігураційних файлах кожного сервісу вказуються параметри `Notify` та `Listen`. Наприклад, у файлі `services.json`:

```json
    "listen": {
      "onReservesData": {
        "topic": "data/reserves/V1",
        "roundrobing": false
      }
    },
    "notify": {
      "drain": {
        "topic": "event/drain/subgraph/V1"
      }
    }
```

##### Екземпляри сервісів

Усі сервіси запускаються в чотирьох екземплярах для кожного протоколу (AAVE V1, AAVE V2, AAVE V3, Compound). Наприклад, ви можете запустити всю систему (archive, proxy, subgraph, data fetcher і transmit) лише для одного протоколу, наприклад, V1.

#### Структура папок

##### Папка Systems

Це головна папка, яка містить файли, відповідальні за роботу архітектури нашої системи.

##### Папка Configs

Тут зберігаються всі конфігураційні файли.

##### Папка Services

Містить точки входу для кожного сервісу.

##### Папка Lib

Містить усі допоміжні бібліотеки. Папка `lib/services` зберігає всі робочі файли певних проектів. Наприклад, проект `subgraph` має свою окрему папку з налаштуваннями та описом, яка знаходиться в `lib/services/subgraph`

#### Шаблони ООП

Усі сервіси побудовані за принципами об'єктно-орієнтованого програмування (ООП). Наприклад:

- **fetcher.js** – головний клас для обробників
- **fetcher-aave.js** – клас для AAVE, який
- **fetcher-aave-v1.js**, **fetcher-aave-v1.js**, **fetcher-aave-v1.js** – класи для різних версій AAVE, які наслідують від **fetcher-aave.js**
- **fetcher-compound.js** – клас для протоколу compound, який наслідує безпосередньо від головного класу **fetcher.js**

#### Механізм черги

Деякі з наших сервісів, такі як Blacklist і Subgraph, мають механізм черги. Мета черги - згладжувати пікові навантаження, які надходять на сервіс. Наприклад, сервіс Proxy надсилає десятки тисяч користувачів до Subgraph за кілька секунд. Subgraph додає цих користувачів до черги, а потім обробляє їх по одному або групами, в порядку черги. Після обробки черга ініціює подію `emit` - яка сповіщає, що черга порожня.

#### Використання форків

##### Що таке форки

Кожен сервіс може працювати в режимі множинних форків, тобто одночасного запуску кількох екземплярів. Це може бути корисно для розподілу навантаження та покращення продуктивності сервісу. Однак, наразі немає сенсу запускати всі сервіси в режимі множинних форків. Це має сенс лише для сервісу Subgraph, особливо коли один протокол (наприклад, AAVE V2) потребує роботи з кількома незалежними екземплярами симулятора. Якщо ви запустите сервіси в режимі множинних форків, але використовуватимете той самий екземпляр симулятора, ви не досягнете жодного покращення швидкості. Наразі ми досягли такої швидкості сервісу, що він оптимально працює в режимі `forks=1`.

##### Параметри форків

У конфігураційних файлах сервісу можна вказати параметри `forks` та `roundrobing`:

- **forks** – кількість одночасних екземплярів сервісу. Наприклад, якщо `forks=2`, сервіс буде запущено у двох екземплярах.
- **roundrobing** – параметр, який визначає, як дані розподіляються між екземплярами:
  - **true** – дані з MQTT надходять до екземплярів по черзі. Наприклад, якщо працюють 2 екземпляри Subgraph, Proxy надішле перших 30 користувачів першому екземпляру, а наступні 30 - другому екземпляру.
  - **false** – дані надходять до кожного екземпляра паралельно. Наприклад, Proxy надішле 30 користувачів кожному екземпляру одночасно.

![Режим форкінгу Cinamon](../images/forkingMode.jpg)

## Висновок

Архітектура проекту побудована на системі Cinnamon і використовує стандартизовані шаблони для забезпечення уніфікованості та ефективності роботи. Кожен сервіс має власні конфігураційні файли, які визначають вхідні та вихідні точки, а також параметри для взаємодії з іншими сервісами через MQTT. Механізм черги допомагає згладжувати пікові навантаження, забезпечуючи стабільну роботу сервісу. Сервіси запускаються через PM2, що забезпечує стабільність, фонову роботу та легкість управління процесами. Режим форків теоретично дозволяє масштабувати сервіси для підвищення продуктивності.
